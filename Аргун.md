## Создать таблицы и задать связи, заполнить данными для следующих примеров:

### 1. Команды и сотрудники:
- команда может иметь несколько сотрудников
- сотрудник может работать только в одной команде
- команда - название, дата создания
- сотрудник - имя, фамилия, должность

### 2. Книги и отзывы:
- книга может иметь несколько отзывов
- отзыв может принадлежать только одной книге
- книга - название, жанр, год издания
- отзыв - текст, оценка

### 3. Рецепты и комментарии:
- рецепт может иметь несколько комментариев
- комментарий может принадлежать только одному рецепту
- рецепт - название, описание, категория
- комментарий - текст, дата публикации

## Для каждого примера сделать вывод связанных сущностей (за один запрос)
- зависимая сущность должна быть представлена в виде массива объектов
- учесть случай когда на главную таблицу может не быть ссылок в строках зависимой таблицы
- если на строки из главной таблицы нет ссылок из зависимой таблицы, эти строки всё равно должны выводиться
- на одну из строк главной таблицы должно быть хотя бы 2 ссылки из зависимой таблицы

1.sql
```SQL
drop table if exists team, staff cascade;

create table team
(
    id         int primary key,
    team_name  text,
    own_date   date
);

create table staff
(
    id         int primary key,
    first_name text,
    last_name  text,
    post       text,
    team_id    int references team
);


insert into team(id, team_name, own_date)
values (1, 'Сатурн', '2020-01-01'),
       (2, 'Британская академия', '2017-01-01'),
       (3, 'Золотой глобус', '2022-01-01'),
       (4, 'Эмми', '2018-01-01'),
       (5, 'Оскар', '2015-01-01');

insert into staff(id, team_id, first_name, last_name, post)
values (1, 2, 'Том', 'Холланд', 'Директор'),
       (2, 2, 'Бенедикт', 'Камбербэтч', 'Менеджер'),
       (3, 3, 'Анастасия', 'Панина', 'Разработчик'),
       (4, 4, 'Бенедикт', 'Камбербэтч', 'Менеджер');

select
s.id,
s.first_name,
s.last_name,
s.post,
coalesce(json_agg(json_build_object(
    'id', t.id, 'team_name', t.team_name, 'own_date', t.own_date))
      filter (where s.id is not null), '[]')
        as staff
from staff s
left join team t on t.id = s.team_id
group by s.id;

select 
t.id,
t.team_name,
t.own_date,
coalesce(json_agg(json_build_object(
    'id', s.id, 'first_name', s.first_name, 'last_name', s.last_name, 'post', s.post))
      filter (where t.id is not null), '[]')
        as team
from team t
left join staff s on s.team_id = t.id
group by t.id;
```
2.sql
```SQL
drop table if exists books, reviews cascade;

create table books
(
    id         int primary key,
    name       text,
    genre      text,
    year       int
);

create table reviews
(
    id       int primary key,
    book_id  int references books,
    p        text,
    mark     int
);


insert into books(id, name, genre, year)
values (1, 'Книга1', 'Жанр1', 2000),
       (2, 'Книга2', 'Жанр2', 2023),
       (3, 'Книга3', 'Жанр3', 2020);

insert into reviews(id, book_id, p, mark)
values (1, 1, 'Отзыв1 о книге1', 1),
       (2, 2, 'Отзыв1 о книге2', 2),
       (3, 3, 'Отзыв1 о книге3', 3),
       (4, 3, 'Отзыв1 о книге3', 4),
       (5, 1, 'Отзыв1 о книге1', 5);

select
  b.id,
  name,
  b.genre,
  year,
  coalesce(json_agg(json_build_object(
    'id', b.id, 'name', name, 'year', year))
      filter (where b.id is not null), '[]')
        as reviews
from books b
left join reviews r on b.id = r.book_id
group by b.id;
```

3.sql
```SQL
drop table if exists recipes, comms cascade;

create table recipes
(
    id         int primary key,
    name       text,
    descr      text,
    category   text
);

create table comms
(
    id          int primary key,
    recipe_id   int references recipes,
    text        text,
    publication date
);


insert into recipes(id, name, descr, category)
values (1, 'рецепт1', 'опис1', 'катег1'),
       (2, 'рецепт2', 'опис2', 'катег2'),
       (3, 'рецепт3', 'опис3', 'катег3');

insert into comms(id, recipe_id, text, publication)
values (1, 1, 'комм1', '1996-06-01'),
       (2, 1, 'комм2', '2017-06-02'),
       (3, 2, 'комм3', '1956-02-03'),
       (4, 2, 'комм4', '2016-05-04'),
       (5, 2, 'комм5', '1916-03-05');

select
  r.id,
  r.name,
  r.descr,
  r.category,
  coalesce(json_agg(json_build_object(
    'id', c.id, 'text', c.text, 'publication', c.publication))
      filter (where c.id is not null), '[]')
        as comms
from recipes r
left join comms c on r.id = c.recipe_id
group by r.id;
```
